<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 读书笔记</title>
    <link>http://hongliya.me/post/</link>
    <description>Recent content in Posts on 读书笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 16 Jan 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://hongliya.me/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JavaScript：null和undefined的区别</title>
      <link>http://hongliya.me/post/javascript_null_undefined/</link>
      <pubDate>Tue, 16 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/javascript_null_undefined/</guid>
      <description>相同点 1.Null和Undefined都只有一个值
 Null的值是null Undefined的值是undefined  2.参与判断的时候都返回false
!null // true !undefined // true  3.Null和Undefined都没有自己的方法
不同点 1.null是关键字，undefined不是关键字
var null; // Uncaught SyntaxError: Unexpected token null var undefined; // undefined  2.声明一个变量但未初始化时，该变量的默认值是undefined，null是已经初始化的一个空对象的指针
var a; // undefined var b = null; // null  3.typeof检测类型时，null会返回&amp;rdquo;object&amp;rdquo;，undefined会返回&amp;rdquo;undefined&amp;rdquo;
typeof null; // &amp;quot;object&amp;quot; typeof undefined; // &amp;quot;undefined&amp;quot;  4.null转换成数字是0，undefined转换成数字是NaN
Number(null); // 0 Number(undefined); // undefined  开发中的注意事项 1.声明变量时尽量初始化一个值（但不要初始化为undefined），因为使用typeof操作符检测声明未赋值的变量和未声明的变量返回的结果都是&amp;rdquo;undefined&amp;rdquo;。
var a; typeof a; // &amp;quot;undefined&amp;quot; typeof b; // &amp;quot;undefined&amp;quot; 注意b并未声明  3.</description>
    </item>
    
    <item>
      <title>JavaScript：一道测试题</title>
      <link>http://hongliya.me/post/javascript_this_1/</link>
      <pubDate>Thu, 11 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/javascript_this_1/</guid>
      <description>记录一道测试题
下面代码运行结果是？（单选）
var x = [].reverse; x();  [] undefined error window  官方答案：D
个人倾向选C
解析：
如果这道题考查的是this指向问题，参考MDN对Array.prototype.reverse()的解释：
 The reverse method transposes the elements of the calling array object in place, mutating the array, and returning a reference to the array.
 Array.prototype.reverse() 最后会返回this指向的调用者，x()的执行环境是全局作用域，那么最后非严格模式下返回的是window，严格模式下返回的是undefined。
单看运行结果，虽然Array.prototype.reverse返回this，但这个 代码片段的运行结果仍然会报错，测试了几个浏览器，全部报了TypeError错误。
Chrome
var x = [].reverse; x(); // Uncaught TypeError: Array.prototype.reverse called on null or undefined at reverse (native)  Firefox
var x = [].reverse; x(); // TypeError: can&#39;t convert undefined to object  Safari</description>
    </item>
    
    <item>
      <title>JavaScript：检测数组</title>
      <link>http://hongliya.me/post/javascript_isarray/</link>
      <pubDate>Thu, 11 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/javascript_isarray/</guid>
      <description>记录如何检测一个对象是不是数组的问题。
有限制的instanceof ECMAScript3规定，对于同一个全局作用域，使用instanceof操作符检测数组就能得到满意的结果：
var colors = [&#39;red&#39;]; if (colors instanceof Array) { // colors是数组 }  使用instanceof操作符检测数组，在同一个全局执行环境中没有问题，但如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数，使用instanceof就不够用了。
大部分浏览器支持的Array.isArray() 为了解决ECMAScript3中的问题，ECMAScript5新增了Array.isArray()方法来检测数组：
var colors = [&#39;red&#39;]; if (Array.isArray(colors)) { // colors是数组 }  Array.isArray()方法优于instanceof，因为Array.isArray()能检测iframes。
支持Array.isArray的浏览器有IE9+、Safari5+、Firefox4+、Chrome。
Polyfill 兼容尚未实现Array.isArray()方法的浏览器
var colors = [&#39;red&#39;]; if (!Array.isArray) { if (isArray(colors)) { // colors是数组 } } // 低版本浏览器检测数组 function isArray(value) { return Object.prototype.toString.call(value) === &amp;quot;[Object Array]&amp;quot;; }  在任何值上调用Object原生的toString()方法都会返回一个[Object NativeConstructorName]格式的字符串。每个类在内部都有一个[[Class]]属性，这个属性就制定了上述字符串中的构造函数名。由于原声数组的构造函数与全局作用域无关，因此使用toString()就能保证返回一致的值，利用这一点就可以自定义上面的isArray函数来检测低版本浏览器的数组。
同样，也可以基于这一思路来检测某个值是不是原生函数或正则表达式：
function isFunction(value) { return Object.prototype.toString.call(value) === &#39;[Object Function]&#39;; } function isRegExp(value) { return Object.</description>
    </item>
    
    <item>
      <title>JavaScript：闭包</title>
      <link>http://hongliya.me/post/javascript_closure/</link>
      <pubDate>Fri, 13 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/javascript_closure/</guid>
      <description> 读书笔记《你不知道的JavaScript（上卷）》作用域闭包。
自问自答  问：怎么理解闭包呢？ 答：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 问：这样说的话，JavaScript中岂不是到处都是闭包？ 答：是的，JavaScript中闭包无处不在。  实例分析 此例子对应：当函数可以记住并访问所在作用域时，就产生了闭包。
function foo() { var a = 2; function bar() { console.log(a); } bar(); } foo();  这个例子看起来就是非常常见的嵌套作用域例子，可能无法清晰的观察闭包，但bar()函数可以记住并访问所在的foo词法作用域（实际上也覆盖了全局作用域），这就产生了闭包。
实例分析 下面的例子清晰的展示了闭包，对应：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。
function foo() { var a = 2; function bar() { console.log(a); } return bar; } var baz = foo(); baz(); // 2  foo作用域执行后并没有被销毁，内部作用域依然存在，bar本身在使用这个作用域，相当于打开一个访问foo作用域的通道（开挂了），bar在自己所在的词法作用域以外的地方执行了，但依然有对自己所在作用域的引用，这个引用就叫闭包。
闭包使函数可以访问定义时的词法作用域。
闭包的用处  可以读取函数内部的变量（如bar就算在外面执行，也能访问到foo内部的变量）。 让这些变量的值始终在内存中（如bar执行完成后foo作用域也不会销毁，而是一直保留在内存中，方便再次使用）。  </description>
    </item>
    
    <item>
      <title>JavaScript：声明提升（hoist）</title>
      <link>http://hongliya.me/post/javascript_hoist/</link>
      <pubDate>Thu, 12 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/javascript_hoist/</guid>
      <description>读书笔记《你不知道的JavaScript（上卷）》提升。
自问自答  问：声明提升是什么鬼？ 答：在JavaScript中，作用域中所有声明（包括变量声明和函数声明）会提升到改作用域的顶部，这就是声明提升。 问：只有声明会提升？赋值操作会不会一起提升？ 答：只有声明会提升，赋值操作和其他逻辑还在原地，如果赋值操作也提升会改变代码的执行顺序，造成非常严重的破坏。 问：该怎么理解这种声明提升呢？ 答：还记得编译原理的第一步么？碰到var a = 2;时，JavaScript会将其看成两个声明：  var a; 编译阶段进行。 a = 2; 执行阶段进行。   实例分析 a = 2; var a; console.log(a); // 2  上面代码实际上是按照以下流程处理的：
var a; // 声明提前 a = 2; // 赋值操作留在原地 console.log(a); // 2  自问自答  问：函数表达式会提升？。 答：函数声明会被提升，但函数表达式不会提升。  实例分析：函数声明提升 foo(); function foo() { console.log(a); var a = 2; }  上面代码实际上是按照以下流程处理的：
function foo() { // 函数foo提升 var a; // 声明提升 console.</description>
    </item>
    
    <item>
      <title>JavaScript：块作用域</title>
      <link>http://hongliya.me/post/javascript_block_scope/</link>
      <pubDate>Wed, 11 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/javascript_block_scope/</guid>
      <description>读书笔记《你不知道的JavaScript（上卷）》块作用域。
表面上看 JavaScript 并没有块作用域的相关功能，其实有。
 with try/catch let  with with会创建一个新的作用域（块作用域），但不推荐使用，不说了。
try/catch ES3规范中规定的try/catch的catch分句会创建一个新的作用域（块作用域），其中声明的变量仅在catch内部有效。
实例分析 try { undefined(); } catch(err) { console.log(err); // TypeError: undefined is not a function } console.log(err); // ReferenceError: err is not defined  栈分析：
第一步：undefined()函数不存在，进入catch作用域，执行完后销毁。
 console作用域   输出结果 &#39;TypeError: undefined is not a function&#39;    catch作用域   调用console.log(err) err = &#39;TypeError: undefined is not a function&#39;    全局作用域   调用undefined()      第一步：调用console.</description>
    </item>
    
    <item>
      <title>JavaScript：匿名函数和具名函数</title>
      <link>http://hongliya.me/post/javascript_anonymous_function/</link>
      <pubDate>Tue, 10 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/javascript_anonymous_function/</guid>
      <description>读书笔记《你不知道的JavaScript（上卷）》函数作用域。
自问自答  问：什么是具名函数？ 答：具名就是具体的名字，就是一个有具体名字的函数，例如function foo() {}，函数的名字叫foo。 问：什么是匿名函数？ 答：匿名就是没有名字，例如常见的回调函数setTimeout(function(){}, 1000)，这里第一个参数就是匿名函数，我们并不知道它的名字是什么。  匿名函数的缺点   匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
 如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑 自身。
 匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让 代码不言自明。
   始终给函数表达式命名是一个最佳实践，例如：
function setTimeout(function timeoutHandler() { // 快看，我有名字了! timeoutHandler // ... }, 1000);  函数定义的两种方式 函数声明 function foo() { }  函数表达式 (function foo() {})  立即执行的函数表达式 IIFE（Immediately Invoked Function Expression）
(function foo() {})(); // 第一个()将函数变成表达式，第二个()执行了这个函数  IIFE 最常见的用法是使用一个匿名函数表达式
(function() {})(); // 第一个()将函数变成表达式，第二个()执行了这个函数  IIFE 的两种写法，功能上是一致的，选择哪种全凭个人喜好：</description>
    </item>
    
    <item>
      <title>JavaScript：避免标识符冲突</title>
      <link>http://hongliya.me/post/javascript_conflict/</link>
      <pubDate>Mon, 09 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/javascript_conflict/</guid>
      <description>读书笔记《你不知道的JavaScript（上卷）》函数作用域。
自问自答  问：标识符冲突是指什么？ 答：写的代码越来越长时可能会声明两个名字相同但用途不同的变量，无意间可能造成命名冲突。 问：名字冲突后会怎么样呢？ 答：冲突会导致变量的值被意外覆盖。  实例分析 function foo() { function bar(a) { i = 3; console.log(a + i); // 3, n个11 } for (var i = 0; i &amp;lt; 10; i++) { bar(i*2); } } foo();  转换成更易理解的代码：
function foo() { var i; function bar(a) { i = 3; console.log(a + i); // 3, n个11 } for (i = 0; i &amp;lt; 10; i++) { bar(i*2); } } foo();  栈分析：</description>
    </item>
    
    <item>
      <title>JavaScript：函数作用域</title>
      <link>http://hongliya.me/post/javascript_function_scope/</link>
      <pubDate>Sun, 08 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/javascript_function_scope/</guid>
      <description>读书笔记《你不知道的JavaScript（上卷）》函数作用域。
自问自答  问：函数作用域是指什么？ 答：函数作用域指的是函数内声明的全部变量都可以在整个函数的范围内使用及复用。 问：整个函数也包括函数中嵌套的函数？ 答：包含。  实例分析 function foo(a) { var b = 2; function bar() { console.log(c); // 3 } bar(); var c = 3; } foo(1); bar(); // ReferenceError: bar is not defined console.log(a); // ReferenceError: a is not defined  代码分析
 全局作用域中包含一个标识符foo foo作用域中包含标识符a、b、bar、c，这些标识符在foo的内部都是可以访问的，但无法从foo外部的作用域访问到这些标识符 bar有自己的作用域  自问自答  问：函数作用域这种设计有什么好处呢？ 答：这种设计非常有用  能充分利用JavaScript变量可以根据需要改变值类型的“动态”特性。 最小限度的暴露必要内容，类似某个模块或对象的API设计。 避免同名标识符之间的冲突，冲突会导致变量的值被意外覆盖。 如果不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，将会更加理想。   实例分析 function doSomething(a) { b = a + doSomethingElse(a * 2); console.</description>
    </item>
    
    <item>
      <title>JavaScript：欺骗词法作用域之with</title>
      <link>http://hongliya.me/post/javascript_with/</link>
      <pubDate>Sat, 07 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/javascript_with/</guid>
      <description>读书笔记《你不知道的JavaScript（上卷）》词法作用域。
欺骗词法作用域会导致性能下降，不推荐使用，因为js解释器编译阶段会对性能进行优化，而使用eval或者with会破坏解释器对作用域的管理规则，解释器怕出问题就不会再优化，所以性能下降。
但仍然要了解下原理。
自问自答  问：with是怎么欺骗（修改）词法作用域的呢？ 答：with可以接受一个对象作为参数，并凭空创建了一个全新的词法作用域，但这个块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中。  实例分析 function foo(obj) { with (obj) { a = 2; } } var o1 = { a: 3 }; foo(o1); console.log(o1.a); // 2  栈分析：
第一步：调用with，with创建新的作用域，改变o1.a的值。
 with作用域   obj.a = 2 (o1.a = 2)    foo作用域   调用with(obj) obj = o1    全局作用域   调用foo(o1) var o1 = { a: 3 }      第二步：with作用域销毁后，回到全局作用域调用console.</description>
    </item>
    
    <item>
      <title>JavaScript：欺骗词法作用域之eval</title>
      <link>http://hongliya.me/post/javascript_eval/</link>
      <pubDate>Fri, 06 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/javascript_eval/</guid>
      <description>读书笔记《你不知道的JavaScript（上卷）》词法作用域。
欺骗词法作用域会导致性能下降，不推荐使用，因为js解释器编译阶段会对性能进行优化，而使用eval或者with会破坏解释器对作用域的管理规则，解释器怕出问题就不会再优化，所以性能下降。
但仍然要了解下原理。
自问自答  问：eval是怎么欺骗（修改）词法作用域的呢？ 答：eval可以接受一个字符串作为参数，并将这个参数偷偷的放进词法作用域中，就好像写代码的时候它就在那里一样。举个例子：把eval比做一个超能力者，它可以修改一个人（名字叫A）的记忆，把一段别人的记忆插入到A的大脑中，让A以为这是自己的记忆。  实例分析 // 正常代码 function foo(str, a) { console.log(a, b); // 1, 2 } var b = 2; foo(&#39;var b = 3;&#39;, 1);  正常代码分析：
 console作用域   输出结果 1, 2    foo作用域   调用console.log(a, b) a = 1 str = &#39;var b = 3&#39;    全局作用域   调用foo(&#39;var b = 3;&#39;, 1) b = 2      参数&amp;rsquo;var b = 3;&amp;lsquo;并未改变任何作用域，只是作为一个普通的字符串参数传进去而已，打印下str仍然是字符串&amp;rsquo;var b = 3;&amp;lsquo;。</description>
    </item>
    
    <item>
      <title>JavaScript：词法作用域</title>
      <link>http://hongliya.me/post/javascript_tokenizing/</link>
      <pubDate>Thu, 05 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/javascript_tokenizing/</guid>
      <description>读书笔记《你不知道的JavaScript（上卷）》词法作用域。
作用域共有两种主要的工作模型  词法作用域 动态作用域  JavaScript并不具备动态作用域，它只有词法作用域，但后面的this机制某种程度上很像动态作用域，该笔记暂不讨论动态作用域。
自问自答  问：该怎么理解词法作用域呢？ 答：这个要回忆下编译原理了。 问：编译器编译的第一步是什么还记得么？ 答：分词/词法分析（Tokenizing/lexing），就是把字符串分解成一个个的词法单元，也叫单词化。 问：这和词法作用域有什么关系呢？ 答：简单地说，词法作用域就是定义在词法分析阶段的作用域，换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的。 问：这么说顺序是不变的么？ 答：大部分情况是这样的，不过还有一些欺骗作用域的方法，这些方法在词法分析器处理过后依然可以修改作用域，不过这些方法不推荐使用。 问：为什么不推荐使用呢？ 答：这个后面再谈&amp;hellip;  实例分析 function foo(a) { var b = a * 2; function bar(c) { console.log(a, b, c); } bar(b*3); } foo(2); // 2, 4, 12  这个例子中共有三个主机嵌套的作用域，为了帮助理解，可以将它们想象成几个逐级包含的气泡，这里借助书中的图片。
 包含着整个全局作用域，其中只有一个标识符：foo。 包含着foo所创建的作用域，其中有三个标识符：a、bar、b。 包含着bar所创建的作用域，其中只有一个标识符：c。  依然用栈分析下：
 console作用域   输出结果 2, 4, 12    bar作用域   调用console.log(c) c = 12    foo作用域   调用bar(b * 3) b = a * 2 = 4 a = 2     全局作用域    调用foo(2)      词法作用域查找只会查找一级标识符，比如a、b、c。如果代码中引用了foo.</description>
    </item>
    
    <item>
      <title>JavaScript：LHS和RHS</title>
      <link>http://hongliya.me/post/javascript_lhs_rhs/</link>
      <pubDate>Wed, 04 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/javascript_lhs_rhs/</guid>
      <description>读书笔记《你不知道的JavaScript（上卷）》作用域。
什么是LHS和RHS？ LHS和RHS是JavaScript引擎执行代码时查找变量的两种方式，L表示左侧，R表示右侧，指的是赋值操作的左侧和右侧。
看了书上的解释，感觉不是那么容易记忆，为了方便自己记忆，我总结如下：
 LHS：给谁赋值 RHS：获取谁的值  例1：获取变量a的值，对a进行RHS查询
console.log(a);  例2：给变量a赋值，对a进行LHS查询
a = 2;  例3：既有LHS查询也有RHS查询
function foo(a) { console.log(a); } foo(2);  例3分析：
 获取foo的值，对foo进行RHS查询 进入foo的作用域，给变量a赋值，对a进行LHS查询 获取变量a的值，对a进行RHS查询 获取console的属性log，对console.log进行RHS查询  这里对于为什么不对foo进行LHS查询，先记录书中解释：
 你可能会倾向于将函数声明function foo(a) {&amp;hellip; 概念化为普通的变量声明 和赋值，比如 var foo、foo = function(a) {&amp;hellip;。如果这样理解的话，这个函数声明将需要进行LHS查询。
而还有一个重要的细微差别，编译器可以在代码生成的同时处理声明和值的定义，比如在引擎执行代码时，并不会有线程专门用来将一个函数值“分配给”foo。因此，将函数声明理解成前面讨论的LHS查询和赋值的形式并不合适。
 例4：找到其中所有的LHS查询（有3处）和RHS查询（有4处）。
function foo(a) { var b = a; return a + b; } var c = foo(2);  例4分析：这是书中的一个小测验，下面是我的分析结果
3处LHS查询：c、a、b
4处RHS查询：foo、a、a、b
 给c赋值，对c进行LHS查询 获取foo的值，对foo进行RHS查询 进入foo的作用域，给a赋值，对a进行LHS查询 获取a的值，对a进行RHS查询 给b赋值，对b进行LHS查询 获取a的值，对a进行RHS查询 获取b的值，对b进行RHS查询  为什么要区分LHS查询和RHS查询？ 因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的结果是不一样的。</description>
    </item>
    
    <item>
      <title>JavaScript：嵌套作用域</title>
      <link>http://hongliya.me/post/javascript_nested_scope/</link>
      <pubDate>Tue, 03 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/javascript_nested_scope/</guid>
      <description> 读书笔记《你不知道的JavaScript（上卷）》嵌套作用域。
自问自答  问：作用域是什么？ 答：作用域是一套规则。 问：一套什么样的规则？ 答：作用域是一套存储变量、修改和访问变量的规则。 问：作用域嵌套是什么鬼？ 答：当一个块或函数嵌套在另外一个块和函数中时，就发生了作用域的嵌套。 问：在嵌套作用域中我该怎么查找我需要的变量？ 答：先在你当前的作用域中找，找不到就去你上级的作用域中找，如果还没有，就一直往上找，直到最外层作用域（全局作用域）中为止。  实例分析 function foo(a) { console.log(a+b); } var b = 2; foo(2);  画了一个简单栈的示意图，根据栈的后进先出规则，每个作用域执行完之后就会弹出变量然后销毁。
 开始创建全局作用域，把变量b压入栈； 执行到foo(2)，创建foo作用域，把a压入栈，再把b压入栈； 执行到console.log(a+b)，创建console作用域，这里粗略画出，实际上里面也有一系列操作，console.log执行完后console作用域销毁，回到foo的作用域； foo作用域执行完后销毁，返回结果4。  前面提到的向上层作用域查找，这里可以理解为在栈中向下查找，比如在foo的作用域中无法查找的变量b，就会向下到全局作用域中查找。
 console作用域   输出结果 4    foo作用域   调用console.log(a+b) a + b = 4 标识符a = 2    全局作用域   调用foo(2) b = 2      </description>
    </item>
    
    <item>
      <title>JavaScript：编译原理初探</title>
      <link>http://hongliya.me/post/javascript_compile/</link>
      <pubDate>Mon, 02 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/javascript_compile/</guid>
      <description> 读书笔记《你不知道的JavaScript（上卷）》编译原理。
JavaScript引擎进行编译的步骤和传统的编译语言非常相似，在某些环节可能比预想的要复杂。
传统编译流程  第一步：分词／词法分析（Tokenizing/Lexing），将字符串分解成对编程语言有意义的代码块（又叫词法单元）。
第二步：解析／语法分析（Parsing），将第一步得到的代码块（词法单元流）转换成一个抽象语法树（Abstract Syntax Tree, AST）。
第三步：代码生成，将第二步得到的AST转换为可执行代码。
 实例分析 var a = 2;  编译过程 第一步：分词／词法分析（Tokenizing/Lexing），将字符串var a = 2;分解成词法单元：var、a、=、2、；。
第二步：解析／语法分析（Parsing），将词法单元流：var、a、=、2、；解析为树（AST）。这里我画了一棵语法树，方便理解，用的是在线制作流程图工具http://www.lizibuluo.com/tree/。
第三步：代码生成，将第二步得到的AST转换为可执行代码。通过某种方法将var a = 2;的AST转化为一组机器指令，创建一个叫做a的变量（包括分配内存等），并将一个值存储到a中。
JavaScript编译流程 JavaScript编译流程和传统编译流程相似，只是在某些环节更复杂，JavaScript编译并不会生成类似.exe的可执行文件，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。
JavaScript编译流程需要编译器和作用域共同完成。
实例分析 var a = 2;  第一步：分词／词法分析（Tokenizing/Lexing），将字符串var a = 2;分解成词法单元：var、a、=、2、；。
第二步：解析／语法分析（Parsing），将词法单元流：var、a、=、2、；解析为树（AST）。这里我画了一棵语法树，方便理解，用的是在线制作流程图工具http://www.lizibuluo.com/tree/。
第三步：代码生成，将第二步得到的AST转换为可执行代码。从这里处理方式开始和传统编译有所不同，编译器会进行如下处理。
编译器和作用域的对话：
 遇到var a，根据不同情况编译器会执行不同的操作；   第一种情况：
 编译器：作用域兄弟，请问是否有一个叫做a的变量存在你的集合中？
作用域：有的。
编译器：好的，谢谢（编译器会忽略var a的声明，继续进行编译）。
 第二种情况：
 编译器：作用域兄弟，请问是否有一个叫做a的变量存在你的集合中？
作用域：没有。
编译器：那帮忙声明一个新的变量吧，就叫a。
  </description>
    </item>
    
    <item>
      <title>JavaScript：引擎初探</title>
      <link>http://hongliya.me/post/javascript_engine/</link>
      <pubDate>Sun, 01 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/javascript_engine/</guid>
      <description>思考出自《你不知道的JavaScript（上卷）》，第一章讲编译原理提到JavaScript引擎。
JavaScript到底是啥？ 维基百科的解释  JavaScript引擎是一个专门处理JavaScript脚本的虚拟机，一般会附带在网页浏览器之中。
 哦，似懂非懂。
思考 计算机只能看懂 0 1 0 1，不能看懂更高层的代码，比如C语言，所以用C语言写好代码之后需要编译一遍，编译器把我们能看懂的代码翻译成计算机能看懂的 0 1 0 1，这样我们的程序才能实现和计算机的交互，我把这里的编译器理解为虚拟机。
相同原理，JavaScript引擎就是把我们写的JavaScript脚本翻译成浏览器能够理解的代码，并给出运行结果。
至于浏览器，其本身就已经被计算机理解。
JavaScript引擎本身也是一段程序，由代码编写而成，如Chrome的JavaScript引擎V8就是用C/C++写的。
总结： JavaScript引擎是专门用来解释和执行JavaScript脚本的虚拟机。</description>
    </item>
    
    <item>
      <title>HTML：meta的一些用法</title>
      <link>http://hongliya.me/post/html_meta/</link>
      <pubDate>Mon, 27 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/html_meta/</guid>
      <description>1.name=&amp;ldquo;keywords&amp;rdquo;
&amp;lt;meta name=&amp;quot;keywords&amp;quot; content=&amp;quot;test&amp;quot; /&amp;gt; // keywords 为文档定义一组关键字，搜索引擎遇到这些关键字的时候会用这些关键字对文档分类  2.name=&amp;ldquo;description&amp;rdquo;
&amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;test&amp;quot; /&amp;gt; // 告诉搜索引擎网站的主要内容  3.http-equiv=&amp;ldquo;content-script-type&amp;rdquo;
&amp;lt;meta http-equiv=&amp;quot;content-script-type&amp;quot; content=&amp;quot;text/javascript&amp;quot; /&amp;gt; // W3C网页规范，指明页面中脚本的类型  4.http-equiv=&amp;ldquo;pragma&amp;rdquo;
&amp;lt;meta http-equiv=&amp;quot;pragma&amp;quot; content=&amp;quot;no-cache&amp;quot; /&amp;gt; // 禁止浏览器从本地计算机的缓存中访问页面内容，这样设定访问者将无法脱机浏览 // 脱机浏览：设置脱机查看网页后，可以在计算机未连接到Internet时阅读网页内容。  5.http-equiv=&amp;ldquo;cache-control&amp;rdquo;
&amp;lt;meta http-equiv=&amp;quot;cache-control&amp;quot; content=&amp;quot;no-cache, must-revalidate&amp;quot; /&amp;gt; // 防止html页面被缓存  6.http-equiv=&amp;ldquo;expires&amp;rdquo;
&amp;lt;meta http-equiv=&amp;quot;expires&amp;quot; content=&amp;quot;0&amp;quot; /&amp;gt; &amp;lt;meta http-equiv=&amp;quot;expires&amp;quot; content=&amp;quot;Mon,12 May 2001 00:20:00 GMT&amp;quot; /&amp;gt; // 设定网页的到期时间，一旦过期必须到服务器上重新调用，需要注意的是必须使用GMT时间格式  7.name=&amp;ldquo;viewport&amp;rdquo;
&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&amp;quot;&amp;gt; // 强制让文档的宽度和设备的宽度保持1:1，并且文档的最大宽度比例是1.0，且不允许用户点击屏幕放大浏览  8.</description>
    </item>
    
    <item>
      <title>Css：css利用边框画三角形</title>
      <link>http://hongliya.me/post/css_border/</link>
      <pubDate>Fri, 24 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/css_border/</guid>
      <description>.border { width: 100px; height: 100px; border: 5px solid red; margin-top: 10px; margin-bottom: 10px; } .border_color { border-top: 5px solid red; border-right: 5px solid yellow; border-bottom: 5px solid blue; border-left: 5px solid green; } .border_bold { border-width: 40px; } .border_inline { display: inline-block; margin-right: 10px; } .border_bolder { border-width: 50px; } .n_l { border-left-color: transparent; } .n_t { border-top-color: transparent; } .n_r { border-right-color: transparent; } .n_b { border-bottom-color: transparent; }  1.</description>
    </item>
    
    <item>
      <title>Tools: sublime冒号后缩进问题</title>
      <link>http://hongliya.me/post/tools_sublime_tab/</link>
      <pubDate>Wed, 20 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/tools_sublime_tab/</guid>
      <description>sublime冒号后缩进自动加分号的解决办法
修改Key Bindings - User 文件
[ { &amp;quot;keys&amp;quot;: [&amp;quot;ctrl+shift+a&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;alignment&amp;quot; }, { &amp;quot;keys&amp;quot;: [&amp;quot;tab&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;insert&amp;quot;, &amp;quot;args&amp;quot;: { &amp;quot;characters&amp;quot;: &amp;quot;\t&amp;quot; }, &amp;quot;context&amp;quot;: [ { &amp;quot;key&amp;quot;: &amp;quot;preceding_text&amp;quot;, &amp;quot;operator&amp;quot;: &amp;quot;regex_contains&amp;quot;, &amp;quot;operand&amp;quot;: &amp;quot;:$&amp;quot;, &amp;quot;match_all&amp;quot;: true } ] } ]  </description>
    </item>
    
    <item>
      <title>Tools: sublime配置文件</title>
      <link>http://hongliya.me/post/tools_sublime/</link>
      <pubDate>Thu, 16 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/tools_sublime/</guid>
      <description>我的Sublime配置文件 编辑器版本：Sublime Text 2
{ // 主题文件路径 &amp;quot;color_scheme&amp;quot;: &amp;quot;Packages/Color Scheme - Default/Monokai.tmTheme&amp;quot;, // 字体 &amp;quot;font-face&amp;quot;: &amp;quot;Consolas&amp;quot;, // 字体大小 &amp;quot;font_size&amp;quot;: 20, // 行号边栏和文字的间距 &amp;quot;margin&amp;quot;: 0, // 突出显示当前光标所在的行 &amp;quot;highlight_line&amp;quot;: true, // 设置每一行到顶部，以像素为单位的间距，效果相当于行距 &amp;quot;line_padding_top&amp;quot;: 0.5, // 按space或tab时，实际会产生白色的点（一个空格一个点）或白色的横线 // 设置为none时，什么情况下都不显示这些点和线 // 设置为selection时，只显示选中状态下的点和线 // 设置为all时，则一直显示 &amp;quot;draw_white_space&amp;quot;: &amp;quot;all&amp;quot;, // 为true时，保存文件时会删除每行结束后多余的空格 &amp;quot;trim_trailing_white_space_on_save&amp;quot;: true, // 为true时，保存文件时光标会在文件的最后向下换一行 &amp;quot;ensure_newline_at_eof_on_save&amp;quot;: true, // 设置为false时，滚动到文本的最下方时，没有缓冲区 // 默认配置文件就是true，但缓冲区没有生效，这里重新定义下就生效了... &amp;quot;scroll_past_end&amp;quot;: true }  默认Sublime Text 2 配置文件  // 主题文件的路径 &amp;quot;color_scheme&amp;quot;: &amp;quot;Packages/Color Scheme - Default/Monokai.</description>
    </item>
    
    <item>
      <title>Mac: Mac配置Apache</title>
      <link>http://hongliya.me/post/mac_apache/</link>
      <pubDate>Wed, 08 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://hongliya.me/post/mac_apache/</guid>
      <description>Mac自带了Apache环境，只需要启动就可以使用。
启动apache
sudo apachectl start  重启apache
sudo apachectl restart  打开Apache的配置文件
sudo vi /etc/apache2/httpd.conf  查看Apache的错误日志
sudo vi /pravite/var/log/apache2/error_log  配置web目录
修改两个地方
 DocumentRoot “你要设置的web目录” &amp;lt;Directory “你要设置的web目录”&amp;gt;  </description>
    </item>
    
  </channel>
</rss>